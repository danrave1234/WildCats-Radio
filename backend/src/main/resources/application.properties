# Basic database configuration
spring.datasource.url=${JDBC_DATABASE_URL}
spring.datasource.username=${JDBC_DATABASE_USERNAME}
spring.datasource.password=${JDBC_DATABASE_PASSWORD}
spring.datasource.driver-class-name=org.postgresql.Driver

# JPA
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=false
spring.jpa.open-in-view=false

# JWT
jwt.secret=${JWT_SECRET}
jwt.expiration=${JWT_EXPIRATION:86400000}

# Email (optional)
spring.mail.host=${MAIL_HOST:smtp.gmail.com}
spring.mail.port=${MAIL_PORT:587}
spring.mail.username=${MAIL_USERNAME:}
spring.mail.password=${MAIL_PASSWORD:}
spring.mail.properties.mail.smtp.auth=true
spring.mail.properties.mail.smtp.starttls.enable=true

# Server
server.port=8080
server.address=0.0.0.0

# Logging
logging.level.com.wildcastradio=INFO

# App domain
app.domain=${APP_DOMAIN:http://localhost:8080}

# Icecast connectivity and credentials
icecast.host=${ICECAST_HOST:icecast.software}
# Listener/admin port (usually 443 on public Icecast behind HTTPS)
icecast.port=${ICECAST_PORT:443}
# Source publishing port (FFmpeg -> Icecast). If your VM blocks 8000 egress, set this to 443 and enable TLS (tls=1).
icecast.source.port=${ICECAST_SOURCE_PORT:8000}
# Optional alternate source port to try if pre-check fails (e.g., 443)
icecast.alt.port=${ICECAST_ALT_PORT:-1}
# Enable a quick TCP pre-check to fail fast and suggest fixes
icecast.precheck.enabled=${ICECAST_PRECHECK_ENABLED:true}
# Credentials and mount
icecast.source.username=${ICECAST_USERNAME:source}
icecast.source.password=${ICECAST_PASSWORD:hackme}
icecast.mount.point=${ICECAST_MOUNT:/live.ogg}
icecast.admin.username=${ICECAST_ADMIN_USERNAME:admin}
icecast.admin.password=${ICECAST_ADMIN_PASSWORD:admin}

# Profile
spring.profiles.active=${SPRING_PROFILES_ACTIVE:default}

# API-wide Rate Limiting (Bucket4j, in-memory)
# Master switch to enable/disable all rate limiting without code changes
ratelimit.enabled=true
# Authentication endpoints (/api/auth/**): limit per unique username/email per minute
ratelimit.auth.per-username-per-minute=5
# Authentication endpoints (/api/auth/**): limit per client IP per minute
ratelimit.auth.per-ip-per-minute=50
# General API endpoints (/api/**): limit per client IP per minute
ratelimit.api.per-ip-per-minute=300
# WebSocket handshake attempts: limit per client IP per minute
# NOTE: Authenticated users with role DJ are EXEMPT from this limit on /ws/live
#       to protect critical broadcast sessions from being blocked by handshake limits.
ratelimit.ws.handshake-per-ip-per-minute=60
# When true, trust X-Forwarded-For header for client IP (useful behind proxies/CDN)
ratelimit.use-x-forwarded-for=true