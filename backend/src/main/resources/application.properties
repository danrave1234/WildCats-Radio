# Basic database configuration
spring.datasource.url=${JDBC_DATABASE_URL}
spring.datasource.username=${JDBC_DATABASE_USERNAME}
spring.datasource.password=${JDBC_DATABASE_PASSWORD}
spring.datasource.driver-class-name=org.postgresql.Driver

# JPA - create/update tables automatically
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=false
spring.jpa.open-in-view=false

# PostgreSQL driver tuning to avoid cached-plan type-change errors during schema updates
# Forces simple query protocol and disables server-side prepared statements for metadata extraction
spring.datasource.hikari.data-source-properties.preferQueryMode=simple
spring.datasource.hikari.data-source-properties.prepareThreshold=0

# HikariCP Connection Pool Optimization
spring.datasource.hikari.maximum-pool-size=20
spring.datasource.hikari.minimum-idle=5
spring.datasource.hikari.connection-timeout=30000
spring.datasource.hikari.idle-timeout=600000
spring.datasource.hikari.max-lifetime=1800000
spring.datasource.hikari.leak-detection-threshold=60000
spring.datasource.hikari.pool-name=WildCatsRadioPool

# JWT
jwt.secret=${JWT_SECRET}
jwt.expiration=${JWT_EXPIRATION:86400000}

# Email (optional)
spring.mail.host=${MAIL_HOST:smtp.gmail.com}
spring.mail.port=${MAIL_PORT:587}
spring.mail.username=${MAIL_USERNAME:}
spring.mail.password=${MAIL_PASSWORD:}
spring.mail.properties.mail.smtp.auth=true
spring.mail.properties.mail.smtp.starttls.enable=true

# Server configuration
server.port=8080
server.address=0.0.0.0

# MVC async request timeout (ms): how long to wait for async (streaming) responses before timing out.
spring.mvc.async.request-timeout=600000
# 10 minutes, configurable via env
# See AsyncConfig.java for async executor pool settings (MVC_ASYNC_CORE, MVC_ASYNC_MAX, etc.)

# Logging
logging.level.com.wildcastradio=INFO
logging.level.org.springframework.orm.jpa=WARN
logging.level.org.hibernate=WARN
logging.level.org.hibernate.SQL=WARN
logging.level.org.hibernate.type.descriptor.sql.BasicBinder=WARN
# Disable verbose Hibernate ORM internal logs
logging.level.org.hibernate.orm.sql=WARN
logging.level.org.hibernate.orm.results=WARN
logging.level.org.hibernate.orm.sql.ast=WARN
logging.level.org.hibernate.orm.results.graph=WARN
logging.level.org.hibernate.orm.sql.exec=WARN
logging.level.org.hibernate.orm.sql.ast.create=WARN
logging.level.tor$SharedEntityManagerInvocationHandler=WARN

# App domain
app.domain=${APP_DOMAIN:http://localhost:8080}

# Timezone configuration (Philippines)
# Ensures consistent serialization and DB handling in Asia/Manila
spring.jackson.time-zone=Asia/Manila
spring.jpa.properties.hibernate.jdbc.time_zone=Asia/Manila

# Radio Agent (Liquidsoap control) configuration, 34.150.12.40 is the static vm ip, 5000 is the python-flask agent listener port
radio.agent.baseUrl=${RADIO_AGENT_BASEURL:http://34.150.12.40:5000}
radio.agent.token=${RADIO_AGENT_TOKEN:hackme}
radio.agent.timeoutMs=${RADIO_AGENT_TIMEOUT_MS:5000}

# Icecast connectivity and credentials
icecast.host=${ICECAST_HOST:icecast.software}
# Listener/admin port (usually 443 on public Icecast behind HTTPS)
icecast.port=${ICECAST_PORT:443}
# Source publishing port (FFmpeg -> Icecast). If your VM blocks 8000 egress, set this to 443 and enable TLS (tls=1).
icecast.source.port=${ICECAST_SOURCE_PORT:8000}
# Optional alternate source port to try if pre-check fails (e.g., 443)
icecast.alt.port=${ICECAST_ALT_PORT:-1}
# Enable a quick TCP pre-check to fail fast and suggest fixes
icecast.precheck.enabled=${ICECAST_PRECHECK_ENABLED:true}
# Credentials and mount
icecast.source.username=${ICECAST_USERNAME:source}
icecast.source.password=${ICECAST_PASSWORD:hackme}
icecast.mount.point=${ICECAST_MOUNT:/live.ogg}
icecast.admin.username=${ICECAST_ADMIN_USERNAME:admin}
icecast.admin.password=${ICECAST_ADMIN_PASSWORD:admin}

# Profile
spring.profiles.active=${SPRING_PROFILES_ACTIVE:default}

# API-wide Rate Limiting (Bucket4j, in-memory)
# Master switch to enable/disable all rate limiting without code changes
ratelimit.enabled=true
# Authentication endpoints (/api/auth/**): limit per unique username/email per minute
ratelimit.auth.per-username-per-minute=5
# Authentication endpoints (/api/auth/**): limit per client IP per minute
ratelimit.auth.per-ip-per-minute=50
# General API endpoints (/api/**): limit per client IP per minute
ratelimit.api.per-ip-per-minute=300
# WebSocket handshake attempts: limit per client IP per minute
# NOTE: Authenticated users with role DJ are EXEMPT from this limit on /ws/live
#       to protect critical broadcast sessions from being blocked by handshake limits.
ratelimit.ws.handshake-per-ip-per-minute=60
# When true, trust X-Forwarded-For header for client IP (useful behind proxies/CDN)
ratelimit.use-x-forwarded-for=true

# WebSocket Performance Optimizations
# Maximum concurrent WebSocket connections (per server instance)
websocket.max-connections=1000
# WebSocket message rate limit per connection per second
websocket.message-rate-limit=50
# Enable WebSocket compression for better performance
websocket.compression.enabled=true
# WebSocket connection idle timeout (5 minutes)
websocket.idle-timeout=300000

# Broadcast Cleanup (stale LIVE broadcasts)
# Enable/disable automatic cleanup of stale broadcasts
broadcast.cleanup.enabled=${BROADCAST_CLEANUP_ENABLED:true}
# Maximum duration a broadcast can be LIVE before auto-ending (hours)
broadcast.cleanup.maxLiveDurationHours=${BROADCAST_CLEANUP_MAX_LIVE_DURATION_HOURS:24}
# Maximum time without checkpoint before considering broadcast stale (minutes)
broadcast.cleanup.staleThresholdMinutes=${BROADCAST_CLEANUP_STALE_THRESHOLD_MINUTES:30}
# Cleanup interval (minutes) - how often to run the cleanup check
broadcast.cleanup.intervalMinutes=${BROADCAST_CLEANUP_INTERVAL_MINUTES:30}

# Source State Classification (Phase 1: Recovery Implementation)
broadcast.recovery.classification.enabled=${BROADCAST_RECOVERY_CLASSIFICATION_ENABLED:true}
broadcast.recovery.classification.networkIssueTimeoutMs=${BROADCAST_RECOVERY_CLASSIFICATION_NETWORK_TIMEOUT_MS:30000}

# Google Cloud Storage for Announcement images
# REQUIRED: name of the bucket where images should be stored
gcs.bucket-name=${GCS_BUCKET_NAME:wildcat-radio.live}
# OPTIONAL: Base64-encoded service account JSON (use instead of GOOGLE_APPLICATION_CREDENTIALS file)
# Example to set (PowerShell): $env:GCS_CREDENTIALS_BASE64 = [Convert]::ToBase64String([IO.File]::ReadAllBytes("path\to\sa.json"))
gcs.credentials.base64=${GCS_CREDENTIALS_BASE64:}
# OPTIONAL: Direct JSON service account credentials (alternative to base64)
gcs.credentials.json=${GCS_CREDENTIALS_JSON:}
# Object key prefix to keep things organized inside the bucket
gcs.announcements.prefix=${GCS_ANNOUNCEMENTS_PREFIX:announcements/}